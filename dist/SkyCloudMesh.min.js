import*as n from"three";function e(e={}){const o={uTime:{value:0},uSunDirection:{value:new n.Vector3(.5,.5,-.5).normalize()},t_PerlinNoise:{value:null},uResolution:{value:new n.Vector2(1920,1080)},uCloudCoverage:{value:e.cloudCoverage??.65},uCloudHeight:{value:e.cloudHeight??600},uCloudThickness:{value:e.cloudThickness??45},uCloudAbsorption:{value:e.cloudAbsorption??1.03},uWindSpeedX:{value:e.windSpeedX??5},uWindSpeedZ:{value:e.windSpeedZ??3},uMaxCloudDistance:{value:e.maxCloudDistance??1e4}},i=new n.ShaderMaterial({vertexShader:"\n        varying vec3 vWorldPosition;\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n            vWorldPosition = worldPosition.xyz;\n            gl_Position = projectionMatrix * viewMatrix * worldPosition;\n        }\n    ",fragmentShader:"\n        precision highp float;\n        precision highp int;\n        uniform float uTime;\n        uniform vec3 uSunDirection;\n        uniform sampler2D t_PerlinNoise;\n        uniform vec2 uResolution;\n        uniform float uCloudCoverage;\n        uniform float uCloudHeight;\n        uniform float uCloudThickness;\n        uniform float uCloudAbsorption;\n        uniform float uWindSpeedX;\n        uniform float uWindSpeedZ;\n        uniform float uMaxCloudDistance;\n        varying vec3 vWorldPosition;\n        varying vec2 vUv;\n        #define TWO_PI 6.28318530718\n        #define STEPS          22\n        #define LIGHT_STEPS    5\n        vec3 Get_Sky_Color(vec3 rayDir) {\n            float sunAmount = max(0.0, dot(rayDir, uSunDirection));\n            float skyGradient = pow(max(0.0, rayDir.y), 0.5);\n            vec3 skyColor = mix(\n                vec3(0.1, 0.2, 0.4),\n                vec3(0.8, 0.7, 0.5),\n                pow(sunAmount, 12.0)\n            );\n            vec3 horizonColor = vec3(0.7, 0.75, 0.8);\n            skyColor = mix(horizonColor, skyColor, skyGradient);\n            if (sunAmount > 0.999) {\n                skyColor += vec3(1.0, 0.7, 0.3) * pow(sunAmount, 1000.0) * 3.0;\n            }\n            return skyColor;\n        }\n        float noise3D(in vec3 p) {\n            vec2 uv = p.xz * 0.01;\n            return texture(t_PerlinNoise, uv).x;\n        }\n        const mat3 m = 1.21 * mat3(0.00, 0.80, 0.60,\n                                  -0.80, 0.36, -0.48,\n                                  -0.60, -0.48, 0.64);\n        float fbm(vec3 p) {\n            float t;\n            float mult = 2.76434;\n            t  = 0.51749673 * noise3D(p); p = m * p * mult;\n            t += 0.25584929 * noise3D(p); p = m * p * mult;\n            t += 0.12527603 * noise3D(p); p = m * p * mult;\n            t += 0.06255931 * noise3D(p);\n            return t;\n        }\n        float cloud_density(vec3 pos, vec3 offset, float h) {\n            vec3 p = pos * 0.0212242 + offset;\n            float dens = fbm(p);\n            float cov = 1.0 - uCloudCoverage;\n            dens *= smoothstep(cov, cov + 0.05, dens);\n            float height = pos.y - uCloudHeight;\n            float heightAttenuation = 1.0 - clamp(height / uCloudThickness, 0.0, 1.0);\n            heightAttenuation = heightAttenuation * heightAttenuation;\n            dens *= heightAttenuation;\n            return clamp(dens, 0.0, 1.0);\n        }\n        float cloud_light(vec3 pos, vec3 dir_step, vec3 offset, float cov) {\n            float T = 1.0;\n            for (int i = 0; i < LIGHT_STEPS; i++) {\n                float dens = cloud_density(pos, offset, 0.0);\n                float T_i = exp(-uCloudAbsorption * dens);\n                T *= T_i;\n                pos += dir_step;\n            }\n            return T;\n        }\n        vec4 render_clouds(vec3 rayOrigin, vec3 rayDirection) {\n            float t = (uCloudHeight - rayOrigin.y) / rayDirection.y;\n            if (t < 0.0) return vec4(0.0);\n            if (t > uMaxCloudDistance) return vec4(0.0);\n            float distanceFade = 1.0 - smoothstep(uMaxCloudDistance * 0.6, uMaxCloudDistance, t);\n            vec3 startPos = rayOrigin + rayDirection * t;\n            vec3 windOffset = vec3(uTime * -uWindSpeedX, 0.0, uTime * -uWindSpeedZ);\n            vec3 pos = startPos;\n            float march_step = uCloudThickness / float(STEPS);\n            vec3 dir_step = rayDirection * march_step;\n            vec3 light_step = uSunDirection * 5.0;\n            float covAmount = (sin(mod(uTime * 0.02, TWO_PI))) * 0.1 + 0.5;\n            float coverage = mix(0.4, 0.6, clamp(covAmount, 0.0, 1.0));\n            float T = 1.0;\n            vec3 C = vec3(0);\n            float alpha = 0.0;\n            for (int i = 0; i < STEPS; i++) {\n                if (pos.y < uCloudHeight || pos.y > uCloudHeight + uCloudThickness) {\n                    pos += dir_step;\n                    continue;\n                }\n                float h = float(i) / float(STEPS);\n                float dens = cloud_density(pos, windOffset, h);\n                if (dens > 0.01) {\n                    float T_i = exp(-uCloudAbsorption * dens * march_step);\n                    T *= T_i;\n                    float cloudLight = cloud_light(pos, light_step, windOffset, coverage);\n                    float lightFactor = (exp(h) / 1.75);\n                    float sunContribution = pow(max(0.0, dot(rayDirection, uSunDirection)), 2.0);\n                    vec3 edgeColor = mix(vec3(1.0), vec3(1.0, 0.8, 0.5), sunContribution);\n                    vec3 cloudColor = mix(\n                        vec3(0.15, 0.15, 0.2),\n                        edgeColor,\n                        cloudLight * lightFactor\n                    );\n                    C += T * cloudColor * dens * march_step * 1.5;\n                    alpha += (1.0 - T_i) * (1.0 - alpha);\n                }\n                pos += dir_step;\n                if (T < 0.01) break;\n            }\n            vec3 sunColor = vec3(0.9, 0.7, 0.5);\n            vec3 skyColor = vec3(0.4, 0.5, 0.6);\n            C = C * mix(skyColor, sunColor, 0.5 * pow(max(0.0, dot(rayDirection, uSunDirection)), 2.0));\n            alpha *= distanceFade;\n            C *= distanceFade;\n            return vec4(C, alpha);\n        }\n        void main() {\n            vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\n            vec3 skyColor = Get_Sky_Color(rayDirection);\n            vec4 clouds = vec4(0.0);\n            if (rayDirection.y > 0.0) {\n                clouds = render_clouds(cameraPosition, rayDirection);\n            }\n            vec3 finalColor = mix(skyColor, clouds.rgb, clouds.a);\n            float t = pow(1.0 - max(0.0, rayDirection.y), 5.0);\n            finalColor = mix(finalColor, vec3(0.65, 0.7, 0.75), 0.5 * t);\n            finalColor = finalColor / (finalColor + vec3(1.0));\n            gl_FragColor = vec4(finalColor, 1.0);\n        }\n    ",uniforms:o,side:n.BackSide}),t=new Uint8Array([128,128,128,255]),r=new n.DataTexture(t,1,1,n.RGBAFormat);return r.needsUpdate=!0,i.uniforms.t_PerlinNoise.value=r,i}function o(n,e){n&&n.uniforms&&n.uniforms.t_PerlinNoise&&(n.uniforms.t_PerlinNoise.value=e,n.needsUpdate=!0)}async function i(i={}){const r=e(i);let a=null;if(i.perlinTextureUrl)try{a=await new Promise(((e,o)=>{(new n.TextureLoader).load(i.perlinTextureUrl,(o=>{o.wrapS=o.wrapT=n.RepeatWrapping,o.flipY=!1,o.minFilter=n.LinearFilter,o.magFilter=n.LinearFilter,o.generateMipmaps=!1,e(o)}),void 0,(n=>o(n)))}))}catch(n){a=t()}else a=t();return o(r,a),r}function t(){const e=256,o=new Uint8Array(262144);for(let n=0;n<262144;n+=4){const e=255*Math.random();o[n]=e,o[n+1]=e,o[n+2]=e,o[n+3]=255}const i=new n.DataTexture(o,e,e,n.RGBAFormat);return i.needsUpdate=!0,i}class r extends n.Mesh{constructor(e={}){const{radius:o=2e4,widthSegments:t=64,heightSegments:r=32,...a}=e;super(new n.SphereGeometry(o,t,r),new n.ShaderMaterial),this.isSkyCloudMesh=!0,i(a).then((n=>{this.material.dispose(),this.material=n}))}updateSun(n){this.material&&this.material.uniforms&&this.material.uniforms.uSunDirection&&this.material.uniforms.uSunDirection.value.copy(n)}updateTime(n){this.material&&this.material.uniforms&&this.material.uniforms.uTime&&(this.material.uniforms.uTime.value=n)}}export{r as SkyCloudMesh,e as createSkyMaterial,i as createSkyMaterialWithTexture,o as setPerlinNoiseTexture};
